syntax = "proto3";

option go_package = "github.com/o7studios/octopus-sdk/go/v1;octopusv1";
option java_package = "studio.o7.octopus.sdk.v1";
option java_multiple_files = true;

package octopus_sdk.v1;

import "google/protobuf/struct.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

service Octopus {
  /**
   * Retrieves existing entries from the database matching a
   * key pattern. Can optionally include expired (include all
   * revisions) objects and filter by creation time.
   */
  rpc Query(QueryRequest) returns (QueryResponse);
  /**
   * Retrieves only one existing entry from the database matching a key.
   */
  rpc Get(GetRequest) returns (GetResponse);
  /**
   * Stores an object on key.
   */
  rpc Write(Object) returns (google.protobuf.Empty);
  /**
   * Stores an object on key in the database and returns the
   * stored version, including the revision and ID.
   */
  rpc Call(Object) returns (Entry);
  /**
   * Bidirectional stream for real-time updates. Clients
   * register for key-patterns (ListenMessage) and receive
   * events (EventCall).
   *
   * Step 1: Registration
   *
   * The client must first send a `ListenMessage` message
   * to specify which key-pattern to listen to.
   *
   * Step 2: Event Reception
   *
   * After registration, the server sends `EventCall` messages
   * for objects matching the registered key-pattern.
   *
   * If you need other keys/more keys you can just send a new
   * `ListenMessage`. This will reset all keys for the current
   * subscription and the new keys will be used.
   */
  rpc Listen(stream ListenMessage) returns(stream EventCall);
}

/**
 * Represents a flexible data object.
 */
message Object {
  // Unique key identifying the object.
  string key = 1;

  // Flexible JSON-like data structure.
  google.protobuf.Struct data = 2;

  // This will create a copy of this object and increment the current revision number.
  bool preserve_previous_entry = 3;

  // Timestamp when the object should no longer be visible by default.
  optional google.protobuf.Timestamp expired_at = 4;

  // Timestamp when the object should be permanently deleted.
  optional google.protobuf.Timestamp deleted_at = 5;
}

/**
 * A versioned object with metadata from database.
 */
message Entry {
  // The underlying object.
  Object object = 1;

  // Entry creation timestamp.
  google.protobuf.Timestamp created_at = 2;

  // Revision number, incremented on every update.
  int64 revision = 3;

  // Unique identifier for this entry.
  string id = 4;
}

/**
 * Filters and options for `Query` RPC.
 */
message QueryRequest {
  // Pattern to match keys. Supports wildcards:
  //   *  — matches exactly one token (between dots), e.g., "foo.*.bar" matches "foo.x.bar" but not "foo.x.y.bar"
  //   >  — matches one or more tokens until the end, e.g., "foo.>" matches "foo", "foo.bar", "foo.bar.baz", etc.
  // Multiple wildcards can be used in a single pattern. Tokens are dot-separated.
  string key_pattern = 1;

  // Whether to include expired objects.
  optional bool include_expired = 2;

  // Start timestamp to filter creation time.
  optional google.protobuf.Timestamp created_at_range_start = 3;

  // End timestamp to filter creation time.
  optional google.protobuf.Timestamp created_at_range_end = 4;

  // Filter by json in data in MongoDB filter similar pattern
  optional string data_filter = 5;

  // Entry paginator
  Paginator paginator = 6;
}

/**
 * For getting an exact value to a key you already have
 */
message GetRequest {
  // Exact key to a object
  string key = 1;
}

message GetResponse {
  oneof result {
    // If the key points only to one value it will be returned
    Object object = 1;
    // If multiple or none objects were found it returns empty
    google.protobuf.Empty empty = 2;
  }
}

/**
 * Paginator for database entry cursor-pagination.
 */
message Paginator {
  // 1-based page index (page=1 is first page)
  int32 page = 1;

  // Number of items to return.
  int32 page_size = 2;
}

message PageInfo {
  int32 current_page = 1;        // current page (1-based)
  int32 current_page_size = 2;   // current page size

  int32 total_pages = 3; // last page number
  int64 total_items = 4; // total matching items

  optional int32 next_page = 5;  // next page number. null if not present
  optional int32 prev_page = 6;  // previous page number. null if not present
}

/**
 * Result of `Get` RPC.
 */
message QueryResponse {
  // List of found entries including revision, ID and timestamps.
  repeated Entry entries = 1;

  // Page information about the cursor.
  PageInfo page_info = 2;
}

/**
 * Message type for the listen stream.
 */
message ListenMessage {
  // Pattern to match keys. Supports wildcards:
  //   *  - matches exactly one token (between dots), e.g., "foo.*.bar" matches "foo.x.bar" but not "foo.x.y.bar"
  //   >  - matches one or more tokens until the end, e.g., "foo.>" matches "foo", "foo.bar", "foo.bar.baz", etc.
  // Multiple wildcards can be used in a single pattern. Tokens are dot-separated.
  repeated string key_pattern = 1;
}

/**
 * Represents a event in the stream.
 */
message EventCall {
  // The affected object.
  Object object = 1;

  // Unique ID for this event call (useful for tracking).
  string call_id = 2;
}
